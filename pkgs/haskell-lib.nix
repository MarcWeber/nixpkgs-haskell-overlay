{ fetchurl, lib } : 
let inherit (builtins) add getAttr hasAttr head tail lessThan sub
    removeAttrs isBool isAttrs isInt isFunction attrNames isString isList compareVersions
    toString addErrorContext listToAttrs trace substring;

    inherit (lib) id mergeAttrs fold
    filter concatLists catAttrs concatStrings mapRecordFlatten concatMapStrings
    any all concatStringsSep mergeAttrsWithFunc nameValuePair attr
    emptyHeadTail attrValues eqStrict flattenAttrs concat mapAttrs elem showVal concatMap
    nixType take mapAttrsFlatten attrSingleton uniqBy getA toStr reverseList
    strict traceCall2 traceVal traceCallXml;

  debug = false; # don't use true when using all packgaes from hackage db. Probably this will exceed your RAM!

  errorContext = false;

  checkTypes = false;

  traceCalls = false;

  libHaskell = {

    # tests in ./tests.nix

### documentation {{{1 

    /*

    # haskell packages planner

    global picture
    ==============

    The planner is fed by a list of available packages and a list of target packages.
    Using this information it tries to create a package dependency tree specifying which
    the dependencies of all the packages should be used to get the targets built.

    The available package list is generated by the tool hack-nix from hackage.
    You can merge in custom package descriptions.

    hint: Nothing is uglier than a untyped lazy language IMHO..
          So I gave some paramter types names starting with "i-" so that I can
          look them up myself..
       

    hack-nix -> available package transformation
    --------------------------------------------

     hack-nix tries to use short names and write the file as compact as possible
     because there are > 1500 packages. Compactness can still be improved (TODO)
     Maybe its best to introduce a import_gzipped function.


    available package
    -----------------
    As cabal allows only one version of a package to be used by a cabal package
    the dependency trees of all executables can be merged.

    ldeps (library) dependencies must be collected separately from executable
    depencies (edeps) because in the final dependeny tree you want to have one
    version for each library.

    When installing multiple libraries and executables you may use filepath-1.0
    and filepath-2.0 for executables of different libraries but not for the
    libraries because a 3rd library might depend on both.

    {
      name = "name";
      version = "2.3";
      fullName = "name-2.3";

      # conditional library dependency tree containing version ranges such as filepath > 2.0
      ldeps = i-dep-node(v-ranges); 

      # conditional executable dependency tree containing version ranges such as filepath > 2.0
      edeps = i-node(v-ranges);

      src = ..; # where to get source from
    };



    prepared package (planner input)
    --------------------------------

    The available package is prepared for the planner:

    * The version ranges found in dependency lists are replaced with sets of
      packages found in the initial set of available packages. This is done so
      that you can merge solution spaces easier.

    * All deps which occur in both edeps, ldeps are removed from edeps and merged with ldeps
      because library and executables must have the same dependencies.

    {
      name = "name";
      version = "2.0";
      fullName = "name-2.0";
      ldeps = i-dep-node(i-set); # conditional dependency tree containing version ranges such as filepath > 2.0
      edeps = i-dep-node(i-set);     # the same
      tflags = { flag = true; } # list of flags which have default value true
      src = ..;
    };


     A package description is mapped [1] to this:
     {
      name = "foo-bar-0.1.2.3"; # the uniq nix attr name

      # [2]
      # library dependencies They are more important because they interfer with other packages 
      ldeps = i-dep-node / i-dep-list; # i-dep-node: before preparation, i-dep-list: after preparation

      # executable dependencies
      edeps = i-dep-node / i-dep-list;

      src = "..." # how to fetch source
     }

    namings:  (i- = info)

    a is either v-ranges or i-set

    i-dep-node(a) : {
        deps = a;
        cdeps = [ i-dep-cond(a) ];
      };

    i-dep-cond(a) : {
      cond      = i-cond;
      if_deps   = i-dep-node(a);
      else_deps = i-dep-node(a);
    }

    i-dep-item :
      { "bytestring" = { # represented as attrs so that hasAttr can be used
          # one of
          "bytestring-0.3" = "0.3";
          "bytestring-0.4" = "0.4";
      };

    i-dep-list :
     dep-item1 // dep-item2 // ... ;

    i-available-packages: {
        "foo-bar" = [ { name = "foo-bar"; version = "1.2.0"; fullName = "foo-bar-1.2.0"; } ]
      };

    i-rigid-flags : attr list of flags { flag = true; flag2 = true; .. }

    # state used while resolving dependencies:
    i-state: {
      resolved: { name : i-resolved }
      al: (i-set) no two versions of the same package allowed here
      resolvingDepsOf: [] # helper list
    }

    i-resolved: 

    i-resolved = {
      pkg-name: {
          version: [ .. ];
          flags : [ .. ];
          resolvedEdeps: {
            names: [ name, name, name ]; # names of resolved dependencies
            state: i-state;
          };
          names: [ name, name, name ]; # names of resolved dependencies
      };
      pkg-name2: { ... }
    }

    i-set: attribute list:
    {
      filepath : {
        "fileptath-1.0" : "1.0";
        "fileptath-2.0" : "2.0";
      };
      [ .. ]
    }
        

    */


    # other solutions: cabal-install. However I don't want to rerun that application over and over again.

    #### tools which could be moved to lib {{{1

    # iterate over each name passing name / attr pairs to f concatenating results
    mapFlattenAttrs = f : attr : fold ( name : l : f name (getAttr name attr) ++ l) [] (attrNames attr);

    # represent list as { "attr" = true; .. } so that "has elem" operations and uniq unions are faster
    # al = attribute list
    alUnion     = mergeAttrs; # x : y : x // y
    alUnionList = lm.mergeAttrsList;
    # only keep names which are present in both - value of a will be taken
    alIntersect = a : b : (removeAttrs a (filter (n : ! hasAttr n b) (attrNames a)));

    catConcatAttrs = name : attrs : concatLists ( catAttrs name attrs );
    mergeAttrsList = attrs : fold (a : b : a // b ) {} attrs;
    catMergeAttrs = name : attrs : lm.mergeAttrsList ( catAttrs name attrs );

    # listToAttrs with merge func for duplicate names 
    listToAttrsMerge = merge :
      fold ( {name, value}: a:
                  let m = if hasAttr name a then
                        merge (getAttr name a) value 
                      else value;
                  in a // attrSingleton name m) {};

    emptyOrMap =  empty : map : l : if l == [] then empty else map l;



    strictf = if debug then
                  x : if isFunction x then (arg : lm.strictf (x arg))
                      else strict x
              else id;

    hstrict = if debug then strict else id;

    addErrorContext2 = x: b:
      if errorContext then addErrorContext "error context : ${x}" b
      else b;

    funcBody = name: body:
      if traceCalls then
        # poor mans profiling:
        builtins.trace "profiling: ${name}" body
      else
        lm.addErrorContext2 name body;


    #### to string functions {{{1

    # only show names
    alToString = al: concatStringsSep " " (attrNames al);

    depListToStr = depList :
      concatStringsSep " " (map (n: "[${lm.alToString (getAttr n depList)}]" ) (attrNames depList));

    assignedPkgToStr = pkg: 
    if pkg ? name && pkg ? edeps && pkg ? ldeps && pkg ? flags then
      toStr {
      inherit (pkg) name;
      edeps = lm.depListToStr pkg.edeps;
      ldeps = lm.depListToStr pkg.ldeps;
      flags = lm.alToString pkg.flags;
      # src isn't important
    } else "not a i-assigned-pkg: ${toStr pkg}";

    #### assertions for tests {{{1

    isPkg = checkDeps: pkg:
      # name
      assert pkg ? name;
      assert isString pkg.name;

      # src
      assert pkg ? src;
      # dependencies
      assert pkg ? edeps;
      
      assert pkg ? ldeps;

      checkDeps pkg.edeps && checkDeps pkg.ldeps
      && isString (pkg.version);


    isCond = x : true; # TODO

    isAttrList = x :
      assert isAttrs x;
      all (x : x == true) (attrValues x);

    # dep with range
    isDepRangeList = x : true; # TODO

    /*
      { name = { name-2.0 = "2.0"; };
        otherName = { otherName-3.0 = "3.0"; };
      }
    */
    isPreparedDepList = x:
      assert isAttrs x;
      all ( byName : all (x : isString x) (attrValues byName)
          ) (attrValues x);

    isDepNode = isDep : node :
      assert isAttrs node;
      assert node ? deps;
      assert node ? cdeps;
         isDep node.deps
      && all (lm.isDepCond isDep) node.cdeps;

    isDepCond = isDep : attr :
      assert isAttrs attr;
      assert attr ? cond;
      assert attr ? if_deps;
      assert attr ? else_deps;
         lm.isCond attr.cond
      && lm.isDepNode isDep attr.if_deps
      && lm.isDepNode isDep attr.else_deps;

    isPreparablePkg = lm.isPkg (lm.isDepNode lm.isDepRangeList);

    isPreparedPkg   = lm.isPkg (lm.isDepNode lm.isPreparedDepList);

    # i-assigned-pkg 
    isPkgWithFlagsAssigned = pkg:
      assert pkg ? flags;
      assert pkg ? ldeps;
      assert pkg ? edeps;
      assert pkg ? src;
      assert pkg ? name;
      true;

    # a target package must have at least a name
    # it may also have version constraints
    isTargetPkg = pkg:
      assert pkg ? n;
      true;


    ### simple comparison - maybe this can be replaced by compareVersions {{{1
    # integer < 0  means less than
    # integer > 0  means greater than
    # integer == 0 means equal
    mO = sub 0 1;

    cmpInts = a : b : sub a b;

    eq  = i : i == 0;       # == 0
    gt  = i : lessThan 0 i; # > 0
    lt  = i : lessThan i 0; # < 0
    lte = i : ! lm.gt i;        # <= 0
    gte = i : ! lm.lt i;        # >= 0

    # vR = serialized haskells VersionRange
    # v  = version
    matchVersion = v : vR : lm.funcBody "matchVersion" (
      if      hasAttr "v" vR then vR.v == v
      else if hasAttr "gt"  vR then lm.gt (compareVersions v vR.gt)
      else if hasAttr "gte" vR then lm.gte (compareVersions v vR.gte)
      else if hasAttr "lt"  vR then lm.lt (compareVersions v vR.lt)
      else if hasAttr "lte" vR then lm.lte (compareVersions v vR.lte)
      else if hasAttr "i1"  vR then (lm.matchVersion v vR.i1) && (lm.matchVersion v vR.i2)
      else if hasAttr "u1"  vR then (lm.matchVersion v vR.u1) || (lm.matchVersion v vR.u2)
      else true); # any version
    
    /*
     returns true / false or
     {
       r(esult) = expr,
       r(igid)f(lags) = { flag  = true; flag2 = true; .. } # list represented as attr for uniqness
     }
    */
    reduceCond = { flags, system, os ? "Linux", compilerFlavor, ... }@opts : expr : lm.funcBody "reduceCond" (
      let simp = lm.reduceCond opts;
      in if isBool expr then expr
         else if isAttrs expr then
           if expr ? os then expr.os == os
           else if expr ? bool then expr.bool
           else if expr ? flag then
             let f = expr.flag;
             in if hasAttr f flags
               then getAttr f flags
               else { r = expr; rf = attrSingleton f true; } # can't simplify, don't know flag value
            else if expr ? not then
              let s = simp expr.not;
              in if isBool s then !s
                 else { inherit (s) rf; r = { not = s.r; }; }
            else if expr ? and then
              let s = map simp expr.and;
                  bools = filter (isBool) s;
                  attrs = filter (isAttrs) s;
              in  if any (x: !x) bools then false
                  else if attrs == [] && all id bools then true
                  else { r = { and = catAttrs "r" attrs; }; rf = lm.catMergeAttrs "rf" attrs; }
            else if expr ? or then
              let s = map simp expr.or;
                  bools = filter (isBool) s;
                  attrs = filter (isAttrs) s;
              in  if any id bools then true
                  else if attrs == [] && all (x: !x) bools then false
                  else { r = { or = catAttrs "r" attrs; }; rf = lm.catMergeAttrs "rf" attrs; }
            else if expr ? compilerFlavor then
                if compilerFlavor.compiler != expr.compilerFlavor then false
                else lm.matchVersion compilerFlavor.version expr.versionRange
            else if expr ? arch then
                     (expr.arch == "x86_64" && system == "x86_64-linux")
                  || (expr.arch == "I386" && system == "i686-linux")
            else if isFunction expr then
              throw "can't reduce a function!"
            else throw "Missing implementation? unexpected! ${builtins.toXML expr}"
         else throw "expected attrs");

    #### preparing package from pkg db list {{{1

      # name + version which can be used as attr (no hyphens, dots, ..)
      mkNixId = pkg : lm.funcBody "mkNixId" "${pkg.name}-${pkg.version}";

      emptyDeps = { cdeps = []; deps = []; };

      # map attr set from file to common format
      # input: read hack-nix output
      # output: as described above in the documentation
      pkgFromDb = pkg : lm.funcBody "pkgFromDb" (
      let # rewrites the shorter representation to attrs
          ifElseToAttrs = list :
            let cond = head list;
                ifelse = tail list;
                if_deps = mapCDeps (head ifelse);
                else_deps = lm.emptyOrMap lm.emptyDeps (x : mapCDeps (head x)) (tail ifelse);
            in { inherit cond if_deps else_deps; };
          mapCDeps = x : x // { cdeps = mapList x.cdeps; };
          mapList = map ifElseToAttrs;
      in {
        inherit (pkg) version name;
        tflags = getA "tflags" pkg [];
        gtk2hsHack = lib.maybeAttr "gtk2hsHack" false pkg; 
        fullName = lm.mkNixId { inherit (pkg) name version; }; 
        # TODO: take Buildable into account
        edeps = lm.addErrorContext2 "edeps in pkgFromDb " (if hasAttr "edeps" pkg then
                  # put all the executable dependencies into one sub deps entry
                  { deps = [];
                    cdeps = map (edep: {
                        cond = true;
                        if_deps = mapCDeps edep;
                        else_deps = lm.emptyDeps;
                      }) pkg.edeps;
                  }
                else lm.emptyDeps);
        ldeps = lm.addErrorContext2 "ldeps in pkgFromDb" (if hasAttr "ldeps" pkg then
                    mapCDeps pkg.ldeps
                else lm.emptyDeps);
        src = if pkg ? srcFile then pkg.srcFile

              # used by hack-nix --to-nix
              else if pkg ? url && pkg ? sha256 then
                fetchurl {
                  inherit (pkg) sha256 url;
                }

              # used by hackage
              else fetchurl {
                url = "http://hackage.haskell.org/packages/archive/${pkg.name}/${pkg.version}/${pkg.name}-${pkg.version}.tar.gz";
                inherit (pkg) sha256;
              };
        # for debugging its more useful to have the path only:
        # src = "http://hackage.haskell.org/packages/archive/${pkg.name}/${version}/${pkg.name}-${version}.tar.gz";
      });

    #### preparing package for planner {{{1


      # versionRangeToAttr rewrites versionRanges by a list of possible packages.
      #
      # availablePackages = {
      #   foo_bar = [ { name = "foo-bar"; version = "1.2.0"; fullName = "foo_bar_1_2_0"; } ]
      # };
      # range = { n = "foo-bar"; gt lt .. };
      # listToAttrs allows "- ." in attr names
      # returns i-dep-list
      versionRangeToAttr = ( availablePackages : range : lm.funcBody "versionRangeToAttr" (
        assert isString range.n;
        let alList = listToAttrs
            (map (i : nameValuePair i.fullName i.version )
                 (filter (x : lm.matchVersion x.version range) (getA range.n availablePackages []))
            );
        in attrSingleton range.n alList));
      

      # availablePackages: i-available-packages: 
      # pkg
      preparePkg = availablePackages : pkg : lm.funcBody "preparePkg" (
      let # input : i-dep-node(v-ranges)
          mapDepNode = strictifyArgs 1 "mapDepNode" ( {deps, cdeps} : {
            deps = lm.mergeDepsIList (map (lm.versionRangeToAttr availablePackages)
                                          (filter (x: x.n != pkg.name) deps) # eg scion's executable dependencies depend on scion library itself. Thus drop dependencies on the same packages
                                     );
            cdeps = map mapDepCond cdeps;
          });
          # input : i-dep-cond(v-ranges)
          mapDepCond = strictifyArgs 1 "mapDepCond" ( a : {
            inherit (a) cond;
            if_deps = mapDepNode a.if_deps;
            else_deps = mapDepNode a.else_deps;
          });
      in pkg // {
        fullName = lm.mkNixId pkg;
        edeps = mapDepNode pkg.edeps;
        ldeps = mapDepNode pkg.ldeps; 
        tflags = ( listToAttrs (map (name: { inherit name; value = true; }) (getA "tflags" pkg [])));
      });

    #### dependency node logic {{{1

    # unite dependency list - used when gathering dependencies
    mergeDepsU = mergeAttrsWithFunc lm.alUnion;

    # i-dep-list1 : i-dep-list2 :
    # returns i-dep-list
    # if both lists contain "bytestring" only keep those versions which are present in both attr lists.
    # TODO change name?
    mergeDepsI = mergeAttrsWithFunc lm.alIntersect;

    mergeDepsIList = fold lm.mergeDepsI {};



    #### helper functions for rigidFlagsAndDeps {{{2
      /* input: i-dep-node(set)
         returns either
          { deps = i-dep-list; } # no more condititions left
         or 
          {
            r  = i-dep-node(set) # maybe simplified version of input
            rf = i-rigid-flags
          }
      */
      redDepNode = ( opts : a : lm.funcBody "redDepNode"
        (
        let inherit (a) deps cdeps; in
        let red_cdeps = map (lm.redDepCond opts) cdeps;
            add_deps  = catAttrs "deps" red_cdeps;
            rf = lm.alUnionList (catAttrs "rf" red_cdeps);
            rest = catAttrs "r" red_cdeps;
            new_deps = lm.mergeDepsIList ([deps] ++ add_deps);
        in if rf == {} then
              { deps = new_deps; }
           else {
             inherit rf;
             r = { deps = new_deps; cdeps = rest; };
           }));

      toDepNode = a : if a ? r then a.r else { inherit (a) deps; cdeps = []; };

      /*
       input: i-dep-cond(set)
       returns either
         { deps = i-dep-list } # no more conditions left
       or
         {
           r  = i-dep-cond(set)
           rf = i-rigid-flags
         }
      */
      redDepCond = opts : node : lm.funcBody "redDepCond" (
        let if_deps   = lm.redDepNode opts node.if_deps;
            else_deps = lm.redDepNode opts node.else_deps;
            red_cond = lm.reduceCond opts node.cond;
            rf = lm.alUnionList ( catAttrs "rf"
                      (if red_cond == true then [if_deps]
                      else if red_cond == false then [else_deps]
                      else [if_deps else_deps red_cond]));
        in if rf == {} then
                assert (isBool red_cond);
                { inherit (if red_cond then if_deps else else_deps) deps; }
          else {
            inherit rf;
            cond = if isBool red_cond then red_cond else red_cond.r;
            if_deps   = lm.toDepNode if_deps;
            else_deps = lm.toDepNode else_deps;
         });
        

    /* simplifies a CondTree by evaluating everything possible of the Condition
       tree predicate. The condition tree describes the dependencies depending on
       constraints such as 

       deps must be i-dep-list

       opts : { os = ...; flags = ..} (same as reduceCond)

       expr: { edeps = ..; ldeps = ..; } # same as

        returns either
        {
          r = { edeps = ..; ldeps = ..; }; # simplified result
          rf = rigid flags see above
        }
        or { # no more rigid flags left, cdeps is gone
          r = i-dep-list
        };

    */
    rigidFlagsAndDeps = opts : expr : lm.funcBody "rigidFlagsAndDeps" (
      assert isAttrs expr;
      let
        red_edeps = lm.redDepNode opts expr.edeps;
        red_ldeps = lm.redDepNode opts expr.ldeps;
        rf = catAttrs "rf" [ red_edeps red_ldeps ];

      in if rf == [] then

          assert attrNames red_ldeps == [ "deps" ];
          assert attrNames red_edeps == [ "deps" ];
          let 

              # new deps for executable and library

              /*
               Also merge all dependencies from edeps into ldeps if already present in ldeps.
               Reason: Cabal only allows the same version of dependency version
               for a .cabal project. Example: the lib depends on { fpath-1.0, fpath-2.0 },
               the executables depend on {fpath-1.0}. Then there is only the one
               fpath-1.0 solution. It has to be tracked in ldeps anyway. So it can be
               removed from edeps.
              */
              ldeps = red_ldeps.deps;
              edeps = red_edeps.deps;

              # only keep what will not merged into ldeps 
              final_edeps = removeAttrs edeps (attrNames ldeps);

              # merge edep dependencies with ldeps
              final_ldeps = lm.mergeDepsI ldeps (removeAttrs edeps (attrNames final_edeps));
          in
            # no rigid flags left. return final dep result 
            {
              r = { edeps = final_edeps; ldeps = final_ldeps; };
            }

         else
          # rigid flags left. return them and a simplified result
          {
            r = expr; # TODO return simplified result ? 
            rf = lm.alUnionList rf;
          } );

    /* checks whether all sets of dependencies still contain at least one element.
       An empty set indicates that no dependency could be found satisfying it
      returns: [ "pkg1" "pkg-2.0" ]
            or pkg
        
    */
    
    missingDepsOrPkg = pkg: lm.funcBody "missingDepsOrPkg" (
      let list =    lm.mapFlattenAttrs (k : v : if v == {} then [k] else []) pkg.ldeps
                 ++ lm.mapFlattenAttrs (k : v : if v == {} then [k] else []) pkg.edeps;
      in if list == [] then pkg else list);



    # takes list of flag names, returns all possible true false flag
    # combinations such as  [ {flagA = true; ..} {flagA = false; ..} { ... } ];
    # tflags: all flags with default value "true"
    # add default flag value at the beginning
    allFlagCombinations = fullName: list : tflags : lm.funcBody "allFlagCombinations" ( emptyHeadTail [ {} ] (name : t :
        let m = if hasAttr name tflags then id else x: !x;
            tru  = listToAttrs [ (nameValuePair name  (m true)) ];
            fals = listToAttrs [ (nameValuePair name (m false)) ];
            ts = lm.allFlagCombinations fullName t tflags;
        in  map (mergeAttrs tru) ts ++ map (mergeAttrs fals) ts
      ) list );

    /*

       pkgVariations: it takes a list of fixed flags determining all possible
       build variations of a package. For this the dependency tries are analyzed
       to extract the remaining rigid flags. Those are assigned true / false in
       all combinations. Only uniq dependency lists are returned. 
       
       Consider:

        if flagA
          if flagB
            bar 3.0
          else
            foo-bar 2.0
        else
          sql-X 20.0

        flagA  | flagB  | list of dependencies
        ====================================
        true   | true   | bar-3.0
        true   | false  | foo-bar 2.0
        false  | true   | sql-X 20.0
        false  | false  | sql-X 20.0  (this one is dropped)

        So it doesn't really matter that rigidFlagsAndDeps result depends on the amount
        of passed fixed flags in the first place.

        opts: same as rigidFlagsAndDeps

        {
          ok = [ i-assigned-pkg ... ];
        } or
        {
          failure = "msg" # typically "no solution, dep xy of pkg-name could not be resolved"
        }
    */

    pkgVariations = (opts: pkg: lm.funcBody "pkgVariations" (
      assert isAttrs pkg;
      let fullName = "${pkg.name}-${pkg.version}";
          r = lm.rigidFlagsAndDeps opts (lm.addErrorContext2 "pkg in pkgVariations" pkg);
          toSolution = r: flags: let R = r.r; in
                          pkg // R // {
                            inherit flags;
                            edeps_str = lm.depListToStr R.edeps; # It's faster to compare strings than traversing the attrs..
                            ldeps_str = lm.depListToStr R.ldeps;
                          };
          list = if r ? rf then
                  map (flags: let r = lm.rigidFlagsAndDeps (opts // { inherit flags; }) (lm.addErrorContext2 "pkg2 in pkgVariations" pkg);
                              in toSolution r flags )
                      (map (mergeAttrs opts.flags) (lm.allFlagCombinations fullName (attrNames r.rf) pkg.tflags)) # all flags combinations
                 else [(toSolution r opts.flags)];
          # TODO filter no-solutions (due to missing deps) 
          judged = map lm.missingDepsOrPkg list;
          solutions =
            (if opts.defaultFlagsOnly then take 1 else id)
            (filter (isAttrs) judged);
        in if solutions != [] then
              # solutions are considered equal when edeps = ldeps
              # which flag assignment wins doesn't matter

              # can be made faster by not comparing version lists ?
              # TODO don't think so so remove this stuff again
              let  compareDeps = p1: p2:
                         (p1.edeps_str == p2.edeps_str)
                      && (p1.ldeps_str == p2.ldeps_str);
              in { ok = uniqBy compareDeps (reverseList solutions); }
          else
            { failure = "\nno solutions found for pkg ${fullName}}. Missing deps depending on flag assignments (all variations): ${toStr judged}"; }
      ));

    # failIfEmpty = l : msg : map : if l == [] then { l : [ msg ]; } else { r : map l };


    #### main entry point / all the work is requested here {{{1


    # Mmh. Probably there are better ways because multiple versions of a package
    # are very likely to have the same dependency configurations
    # However I couldn't find an implementation within a given time so I'll work on this later.
    # I'd like to get done any implementation first
    # speed can be enhanced by choosing sensible default flags for packages.
    # This reduces the possibilities a lot.
    #
    # each package in the target list has to be uniq. Thus you can't find
    # solutions for HaXml-1.13 and HaXml-1.19 at the same time!
    #
    # note: default is to not add provided packages to the resolved list at the beginning.
    #       So base-3 or base-4 can be choosen because only one is allowed to be in resolved.
    #       However if you have a package only specifying a "base" dependency
    #       cabal may choose to base-4 even though this solver has assigned base-3!
    #       TODO have a look at cabal and see whether you can tell it which
    #       library to use!
    resolveDependenciesBruteforce = {

      /* the system. Used for checking arch flag of cabal
      */
      system,

      /* example:
       globalFlags = {
        splitBase = true;
       }
      */
      globalFlags ? {},

      /* example:
      { # both constraints will be applied to Cabal-1.4.4 
        Cabal-1.4.4 = {
           splitBase = false;
        };
        # for all Cabal versions use:
        Cabal = {
           splitBase = false;
        };
      }
      */
      packageFlags ? {},

      /* the packages to create derivations for
         for example: [ { n = "Cabal"; v = "1.4.0.0"; }
                        { n = "byestring"; }
                        { n = "byestring"; gt(e) /lt(e) = "1.4.0.0 }
                        "network-bytestring" # shortcut for { n = ..; }
                      ];
      */
      targetPackages,

      /* the list of available packages.
         This list is read from a file created by hack-nix and prepared by 
         You can also add custom packages manually here
      */
      packages,

      /*  list of packages (ghc core packages) which are provided */
      provided
        # example list (ghc-6.10.4)
        ? [
            [ "Cabal" "1.6.0.3" ]
            [ "array" "0.2.0.0" ]
            [ "base" "3.0.3.1" ]
            [ "base" "4.1.0.0" ]
            [ "bytestring" "0.9.1.4" ]
            [ "containers" "0.2.0.1" ]
            [ "directory" "1.0.0.3" ]
            [ "extensible-exceptions" "0.1.1.0" ]
            [ "filepath" "1.1.0.2" ]
            [ "ghc" "6.10.4" ]
            [ "ghc-prim" "0.1.0.0" ]
            [ "haddock" "2.4.2" ]
            [ "haskell98" "1.0.1.0" ]
            [ "hpc" "0.5.0.3" ]
            [ "integer" "0.1.0.1" ]
            [ "old-locale" "1.0.0.1" ]
            [ "old-time" "1.0.0.2" ]
            [ "packedstring" "0.1.0.1" ]
            [ "pretty" "1.0.1.0" ]
            [ "process" "1.0.1.1" ]
            [ "random" "1.0.0.1" ]
            [ "rts" "1.0" ]
            [ "syb" "0.1.0.1" ]
            [ "template-haskell" "2.3.0.1" ]
            [ "unix" "2.3.2.0" ]
          ],

        skipProvidedInFavourOfNewer ? true,

        # a list of all possible flag combinations is built.
        # The head of the list is using default flag settings.
        # combinations which have no solution (missing deps)
        # are discarded. If you set defaultFlagsOnly to true
        # only the head of the list having most default settitngs will be used.
        defaultFlagsOnly ? true,

        # filter is used to remove packages from provided and packages list.
        # Example: only keep base >= 4
        # { base = { gte = "4"; }; }
        filtersByName ? {},

        os ? "Linux",

        compilerFlavor ? { compiler = "GHC"; version = "ghc-6.10"; },


        # function creating the final derivation
        # this function should merge in package specific things like
        # C dependencies etc. Dependencies should be fed into propagatedBuildInputs
        mkHaskellDerivation ?
          { name, fullName, src, dependencies, flags, patches, version, ... }:
          throw "you didn't pass mkDerivation !",


        # set to true to get *many* trace messages about failures
        # resolving package dependencies
        # This may give you a hint on how to optimise finding a solution
        # by adding constraints or find out why no solution can be found
        # TODO enhance this
        debugS ? false,         

        # allow but ignore passing additional arguments
        ... 
    }:

    assert isList targetPackages;

    let

      filterByName = filter (x:
          let name = x.name;
          in if hasAttr name filtersByName then lm.matchVersion x.version (getAttr name filtersByName)
          else true );

      filterIfNewerAvailable = if !skipProvidedInFavourOfNewer
        then id
        else
          let byName = lm.listToAttrsMerge concat (map (p: nameValuePair p.name [{ inherit (p) fullName version name; }] ) packages);
          in filter (x: 
              let name = x.name;
              in if hasAttr name byName
                  then !any (p: lm.gt (compareVersions p.version x.version)) (getAttr name byName)
                  else true
            );

      traceFailure = msg: if debugS then trace msg [] else [];

      preparedTP = map (p:
          let r = if isString p then { n = p;} else p;
          in assert lm.isTargetPkg r; r) targetPackages;

      # replace target strings by package version range with name so that they
      # can be used as dependency description
      targetRanges = map (t: if isString t then { n = t; } else t) targetPackages;

      # name without version
      targetNames = map (t: if isString t then t else t.n) targetPackages;

      # create special package depending on targets to find solution for all targets
      targetPackage = rec {
        name = "nix-special-target-extra-package";
        version = "0";
        fullName = "${name}-0";

        # conditional library dependency tree containing version ranges such as filepath > 2.0
        ldeps =  {
          cdeps = [];
          deps = targetRanges;
        };

        edeps = {
          cdeps = [];
          deps = [];
        };

        src = "this is never used";
      };
      
      # list of { fullName =, version = , name} for all the packages shipping with ghc
      providedList = filterIfNewerAvailable ( filterByName (map (x:
              let name = head x;
                  version = head (tail x);
              in {
                inherit name version;
                fullName = lm.mkNixId { inherit name version; }; 
                edeps = { cdeps = []; deps  = []; };
                ldeps = { cdeps = []; deps  = []; };
                provided = true;
                src = "never used";
          }) provided));

      allPackages = let ap = (filterByName packages) ++ providedList ++ [targetPackage];
                    in assert all lm.isPreparablePkg ap; ap;

      # now replace version constraint ranges (eg >3 && <5)  by version sets (eg one of 3.5 4 4.6).
      prepared = (
        let av = lm.listToAttrsMerge concat
                                   (map (p: nameValuePair p.name [{ inherit (p) fullName version name; }] ) (allPackages));
        in
           map (lm.preparePkg av) allPackages);

      # sort by full name so that look up is fast
      available = listToAttrs
        (map (p: nameValuePair p.fullName p) prepared);

      providedInResolved = false;

      # i-state
      initialState = {

        # resolved : i-resolved;
        resolved = if providedInResolved then
                      listToAttrs (map (x: nameValuePair x.name x) providedList)
                   else {}; 

        al = if providedInResolved then
                listToAttrs (map (x: nameValuePair x.name (attrSingleton x.fullName x.version) ) providedList)
              else {};

        # keep a list of the packages which are currently resolved to find circular
        # dependencies. This should never happen but who knows?
        resolvingDepsOf = [];

      };

      # returns
      # - [ state ]: dep has already been resolved
      # - []: dep can't be met
      #      (either another version has been selected or it dosen't exist)
      # - [ state ... ]: ways to resolve package
      # args
      #   dep: item of i-dep-list { name =, version=, fullName= .. };
      resolveDep = state@{resolved, resolvingDepsOf, ...}: dep@{name, version, fullName, ...}: lm.addErrorContext2 "resolveDep" (
        if elem name resolvingDepsOf then throw "circular dependencies: ${showVal resolvingDepsOf} ${name}"
        else


        if hasAttr name resolved then
          let r = getAttr name resolved;
          in if r.version == version then [ state ]
             else traceFailure "request to resolve package but version missmatch ${fullName}, resolved version: ${r.version}"
        else
          # package hasn't been resolved yet, do so by looking it up in availablePackages
          if !hasAttr fullName available then traceFailure "no package information about ${fullName} "
          else
            # now resolve deps of dep recursively.
            let  state2 = state // { resolvingDepsOf = state.resolvingDepsOf ++ [ fullName ]; };
                 preparedPkg = getAttr fullName available;
                 flagsByName            = getA name packageFlags {};
                 flagsByNameAndVersion  = getA fullName packageFlags {};
                 flags = globalFlags // flagsByName // flagsByNameAndVersion;
                 opts = { inherit os compilerFlavor flags defaultFlagsOnly system; };
                 # opts = { inherit os  compilerFlavor; flags = (builtins.trace " fullname: ${fullName}\n flagsByName ${name} ${toStr flagsByName }\n flagsByNameAndVersion ${fullName} ${toStr flagsByNameAndVersion} \n package Flags: ${toStr packageFlags} " flags); };
                 variations = lm.pkgVariations opts preparedPkg;

                 # return all solutions for deps maybe resolving different versions of the same package found in set
                 resolveDepsOfSet = state: set:
                   let resolveDeps = st: list:
                          if list == [] then [st]
                          else let h = head list;
                                   t = tail list;
                               in concatMap (dep: resolveThisDep st dep t) h;
                       resolveThisDep = st: dep: tail:
                        let r = resolveDep st dep;
                        in if r == true then resolveDeps st tail # has been resolved by resolving dependency of a previous item of set
                           else concatMap (s: resolveDeps s tail) r;

                   in resolveDeps state
                       # [ [ a-1.0  a-2.0 ] [ b-1.0  b-2.0 ] ] where a-1.0 is { name=, version, fullName } etc
                       (mapAttrsFlatten (name: mapAttrsFlatten (fullName: version: {inherit name fullName version;}) ) set);
                 finishtrace = var: 
                   let r = finish var;
                   in if debugS then
                      builtins.trace
                       ("variation : ${concatStringsSep "" ( map (x: "\"") state.resolvingDepsOf)} => (${dep.fullName}) flags: ${toStr var.flags}")
                       r
                   else r;

                 # resolve deps of pkg variation. return new state list, [] if
                 # there is no solution
                 finish = var@{name, ...}:
                   let
                      # remove versions which differ from resolved versions
                      ldepAl = lm.mergeDepsI state2.al var.ldeps;
                   in if any (x: x == {}) (attrValues ldepAl) then
                        # some ldeps have different versions. No match. break
                        traceFailure ("deps of ${fullName} don't match resolved versions."
                            + "\nresolved: ${lm.depListToStr (removeAttrs state2.al (filter (n: ! elem n (attrNames var.ldeps)) (attrNames state2.al)) )}:"
                            + "\nrequired: ${lm.depListToStr var.ldeps}")
                      else
                        let # find depedencies which haven't been resolved yet
                            ldepResolve = removeAttrs ldepAl (attrNames state2.al);
                            # find solutions for them:
                            ldepStates = resolveDepsOfSet state2 ldepResolve;

                            # the remaining edeps are orthogonal to ledeps.
                            # common deps have been moved to ldeps

                            # now resolve executable dependencies after having resolved
                            # library dependencies.
                            # depndencies of the executable dependencies might depend on
                            # dependencies of library dependencies - and versions of
                            # those should match - so it's important that library
                            # dependencies have been resolved first
                            states = concatMap ( lstate:
                                let estates = resolveDepsOfSet lstate var.edeps;
                                in if estates == [] then traceFailure "edeps of ${fullName} "
                                else [ {
                                  inherit lstate;
                                  resolvedEdeps = {
                                    names = attrNames var.edeps;
                                    state = head estates;
                                  };
                                } ]
                                ) ldepStates;
                           in
                            if ldepStates == [] then traceFailure "ldeps of ${fullName}"
                            else # 
                              map ({lstate, resolvedEdeps}:
                                    lstate // {
                                      resolved = lstate.resolved // attrSingleton name {
                                        inherit (var) version flags fullName name src gtk2hsHack;
                                        inherit resolvedEdeps;
                                        provided = preparedPkg ? provided;
                                        names = attrNames var.ldeps;
                                      };
                                      al = lstate.al // attrSingleton name (attrSingleton fullName version);
                                    }
                                  ) states;

            in if variations ? failure then traceFailure "getting variations for of ${fullName} reason: ${variations.failure}"
               else concatMap finishtrace (variations.ok));

        toDerivation = state: name: lm.funcBody "toDerivation" (
          let resolved = getAttr name state.resolved;
              re = resolved.resolvedEdeps;
          in if resolved.provided then null # provided means the package is shipped with the ghc compiler
             else mkHaskellDerivation {
                inherit (resolved) flags fullName name src version gtk2hsHack;
                dependencies = filter (x : x != null)
                  (
                    # dependencies of libraries
                      map (toDerivation state) resolved.names
                    # dependendencies of executables
                    ++ map (toDerivation re.state) re.names
                  );
                patches =
                  let patch = ../patches + "/${resolved.fullName}.patch";
                  in  lib.optional (builtins.pathExists patch)  patch;
              });

        # start the (infinite ? :-/) brute force work
        ways = resolveDep initialState targetPackage;
        
      in
      if false then prepared
      else
      if ways == [] then throw "no solution found for targets ${builtins.toXML targetPackages}"
      else 
        let solution = head ways; # one solution is enough
        in listToAttrs (map (n: nameValuePair n (toDerivation solution n)) targetNames);

    };

    # evaluate argument before passing it to the functions so that error appear as early as possible
    strictifyArgs = nr: name: expr:
      if debug && isFunction expr then
          (arg: strictifyArgs (builtins.add 1 nr) name
                              (expr (addErrorContext "while evaluating arg ${builtins.toString nr} of ${name}"
                                                     (lib.strict arg) )) 
          )
      else expr;

    # lib modified. optionally strictify arguments. This helps tracking down errors
    lm = if !debug then libHaskell
      else mapAttrs ( name: value:
        if (substring 0 2 name == "is" && !checkTypes) then
          x : true
        else
          if name == "strict" 
          || name == "strictf"
          || name == "hstrict"
          || name == "addErrorContext2"
          then value
          else strictifyArgs 1 name value
    ) libHaskell;

in lm
# set fdm=marker
